//! Implementing the sumcheck protocol of the virtual polynomial
//! This sum check is heavily copied fron the implemenation done by Ezpressolabs
use ark_ff::PrimeField;
use fiat_shamir::{FiatShamirTranscript, TranscriptInterface};
use polynomial::{multilinear::Multilinear, virtual_polynomial::VirtualPolynomial};
use prover::VirtualProver;
use std::{fmt::Debug, marker::PhantomData};
use verifier::VirtualVerifier;
pub mod prover;
pub mod verifier;

/// Trait for doing sum check protocols.
pub trait SumCheck<F: PrimeField> {
    type VirtualPolynomial;
    type VPAuxInfo;
    type MultilinearExtension;

    type SumCheckProof: Clone + Debug + Default + PartialEq;
    type Transcript;
    type SumCheckSubClaim: Clone + Debug + Default + PartialEq;

    /// Extract sum from the proof
    fn extract_sum(proof: &Self::SumCheckProof) -> F;

    /// Initialize the system with a transcript
    ///
    /// This function is optional -- in the case where a SumCheck is
    /// an building block for a more complex protocol, the transcript
    /// may be initialized by this complex protocol, and passed to the
    /// SumCheck prover/verifier.
    fn init_transcript() -> Self::Transcript;

    /// Generate proof of the sum of polynomial over {0,1}^`num_vars`
    ///
    /// The polynomial is represented in the form of a VirtualPolynomial.
    fn prove(
        poly: &Self::VirtualPolynomial,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::SumCheckProof, anyhow::Error>;

    /// Verify the claimed sum using the proof
    fn verify(
        sum: F,
        proof: &Self::SumCheckProof,
        aux_info: &Self::VPAuxInfo,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::SumCheckSubClaim, anyhow::Error>;
}

/// Trait for sum check protocol prover side APIs.
pub trait SumCheckProver<F: PrimeField>
where
    Self: Sized,
{
    type VirtualPolynomial;
    type ProverMessage;

    /// Initialize the prover state to argue for the sum of the input polynomial
    /// over {0,1}^`num_vars`.
    fn prover_init(polynomial: &Self::VirtualPolynomial) -> Result<Self, anyhow::Error>;

    /// Receive message from verifier, generate prover message, and proceed to
    /// next round.
    ///
    /// Main algorithm used is from section 3.2 of [XZZPS19](https://eprint.iacr.org/2019/317.pdf#subsection.3.2).
    fn prove_round_and_update_state(
        &mut self,
        challenge: &Option<F>,
    ) -> Result<Self::ProverMessage, anyhow::Error>;
}

/// Trait for sum check protocol verifier side APIs.
pub trait SumCheckVerifier<F: PrimeField> {
    type VPAuxInfo;
    type ProverMessage;
    type Challenge;
    type Transcript;
    type SumCheckSubClaim;

    /// Initialize the verifier's state.
    fn verifier_init(index_info: &Self::VPAuxInfo) -> Self;

    /// Run verifier for the current round, given a prover message.
    ///
    /// Note that `verify_round_and_update_state` only samples and stores
    /// challenges; and update the verifier's state accordingly. The actual
    /// verifications are deferred (in batch) to `check_and_generate_subclaim`
    /// at the last step.
    fn verify_round_and_update_state(
        &mut self,
        prover_msg: &Self::ProverMessage,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::Challenge, anyhow::Error>;

    /// This function verifies the deferred checks in the interactive version of
    /// the protocol; and generate the subclaim. Returns an error if the
    /// proof failed to verify.
    ///
    /// If the asserted sum is correct, then the multilinear polynomial
    /// evaluated at `subclaim.point` will be `subclaim.expected_evaluation`.
    /// Otherwise, it is highly unlikely that those two will be equal.
    /// Larger field size guarantees smaller soundness error.
    fn check_and_generate_subclaim(
        &self,
        asserted_sum: &F,
    ) -> Result<Self::SumCheckSubClaim, anyhow::Error>;
}

/// A SumCheckSubClaim is a claim generated by the verifier at the end of
/// verification when it is convinced.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckSubClaim<F: PrimeField> {
    /// the multi-dimensional point that this multilinear extension is evaluated
    /// to
    pub point: Vec<F>,
    /// the expected evaluation
    pub expected_evaluation: F,
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckProverMessage<F: PrimeField> {
    pub(crate) evaluations: Vec<F>,
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct SumCheckProof<F: PrimeField> {
    pub point: Vec<F>,
    pub proofs: Vec<SumCheckProverMessage<F>>,
}

pub fn vp_aux_info_to_bytes(index_info: (usize, usize)) -> Vec<u8> {
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&index_info.0.to_le_bytes());
    bytes.extend_from_slice(&index_info.1.to_le_bytes());
    bytes
}

/// This is the API entry point for the Virtual Polynomial Sum Check protocol.
/// It provides a high-level interface for constructing and verifying proofs.
pub struct VirtualPolySumCheck<F: PrimeField> {
    _marker: PhantomData<F>,
}

impl<F: PrimeField> SumCheckProverMessage<F> {
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&self.evaluations.len().to_le_bytes());
        for eval in &self.evaluations {
            bytes.extend_from_slice(&eval.to_string().as_bytes());
        }
        bytes
    }
}

impl<F: PrimeField> SumCheck<F> for VirtualPolySumCheck<F> {
    type VirtualPolynomial = VirtualPolynomial<F>;
    type VPAuxInfo = (usize, usize);
    type MultilinearExtension = Multilinear<F>;
    type SumCheckProof = SumCheckProof<F>;
    type Transcript = FiatShamirTranscript;
    type SumCheckSubClaim = SumCheckSubClaim<F>;

    fn extract_sum(proof: &Self::SumCheckProof) -> F {
        proof.proofs[0].evaluations[0] + proof.proofs[0].evaluations[1]
    }

    fn init_transcript() -> Self::Transcript {
        FiatShamirTranscript::default()
    }

    fn prove(
        poly: &Self::VirtualPolynomial,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::SumCheckProof, anyhow::Error> {
        transcript.append_with_label(
            "aux info",
            vp_aux_info_to_bytes((poly.num_var, poly.max_degree)),
        );

        let mut prover_state = VirtualProver::prover_init(poly)?;
        let mut challenge = None;
        let mut prover_msgs = Vec::with_capacity(poly.num_var);
        for _ in 0..poly.num_var {
            let prover_msg =
                VirtualProver::prove_round_and_update_state(&mut prover_state, &challenge)?;
            transcript.append_with_label("prover msg", prover_msg.to_bytes());
            prover_msgs.push(prover_msg);
            challenge = Some(transcript.sample_as_field_element());
            transcript.append(b"Internal round".to_vec());
        }
        // pushing the last challenge point to the state
        if let Some(p) = challenge {
            prover_state.challenges.push(p)
        };

        Ok(SumCheckProof {
            point: prover_state.challenges,
            proofs: prover_msgs,
        })
    }

    fn verify(
        claimed_sum: F,
        proof: &Self::SumCheckProof,
        aux_info: &Self::VPAuxInfo,
        transcript: &mut Self::Transcript,
    ) -> Result<Self::SumCheckSubClaim, anyhow::Error> {
        transcript.append_with_label("aux info", vp_aux_info_to_bytes((aux_info.0, aux_info.1)));

        let mut verifier_state = VirtualVerifier::verifier_init(aux_info);
        for i in 0..aux_info.0 {
            let prover_msg = proof.proofs.get(i).expect("proof is incomplete");
            transcript.append_with_label("prover msg", prover_msg.to_bytes());

            VirtualVerifier::verify_round_and_update_state(
                &mut verifier_state,
                prover_msg,
                transcript,
            )?;
        }

        let res = VirtualVerifier::check_and_generate_subclaim(&verifier_state, &claimed_sum);
        res
    }
}

#[cfg(test)]
mod test {

    use std::sync::Arc;

    use super::*;
    use anyhow::Ok;
    use ark_ff::UniformRand;
    use ark_std::test_rng;
    use ark_test_curves::bls12_381::Fr;

    fn test_sumcheck(
        nv: usize,
        num_multiplicands_range: (usize, usize),
        num_products: usize,
    ) -> Result<(), anyhow::Error> {
        let mut rng = test_rng();
        let mut transcript = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::init_transcript();

        let (poly, asserted_sum) =
            VirtualPolynomial::rand(nv, num_multiplicands_range, num_products, &mut rng)?;
        let proof = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::prove(&poly, &mut transcript)?;
        let poly_info = (poly.num_var, poly.max_degree);
        let mut transcript = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::init_transcript();
        let subclaim = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::verify(
            asserted_sum,
            &proof,
            &poly_info,
            &mut transcript,
        )?;
        assert!(
            poly.evaluate(&subclaim.point).unwrap() == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }

    fn test_sumcheck_internal(
        nv: usize,
        num_multiplicands_range: (usize, usize),
        num_products: usize,
    ) -> Result<(), anyhow::Error> {
        let mut rng = test_rng();
        let (poly, asserted_sum) =
            VirtualPolynomial::<Fr>::rand(nv, num_multiplicands_range, num_products, &mut rng)?;
        let poly_info = (poly.num_var, poly.max_degree);
        let mut prover_state = VirtualProver::prover_init(&poly)?;
        let mut verifier_state = VirtualVerifier::verifier_init(&poly_info);
        let mut challenge = None;
        let mut transcript = FiatShamirTranscript::default();
        transcript.append_with_label("testing", b"initializing transcript for testing".to_vec());
        for _ in 0..poly.num_var {
            let prover_message =
                VirtualProver::prove_round_and_update_state(&mut prover_state, &challenge).unwrap();

            challenge = Some(
                VirtualVerifier::verify_round_and_update_state(
                    &mut verifier_state,
                    &prover_message,
                    &mut transcript,
                )
                .unwrap(),
            );
        }
        let subclaim = VirtualVerifier::check_and_generate_subclaim(&verifier_state, &asserted_sum)
            .expect("fail to generate subclaim");
        assert!(
            poly.evaluate(&subclaim.point).unwrap() == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }

    #[test]
    fn test_trivial_polynomial_vs() -> Result<(), anyhow::Error> {
        let nv = 1;
        let num_multiplicands_range = (4, 13);
        let num_products = 5;

        test_sumcheck(nv, num_multiplicands_range, num_products)?;
        // test_sumcheck_internal(nv, num_multiplicands_range, num_products)
        Ok(())
    }
    #[test]
    #[ignore]
    fn test_normal_polynomial() -> Result<(), anyhow::Error> {
        let nv = 12;
        let num_multiplicands_range = (4, 9);
        let num_products = 5;

        test_sumcheck(nv, num_multiplicands_range, num_products)?;
        test_sumcheck_internal(nv, num_multiplicands_range, num_products)
    }
    #[test]
    fn zero_polynomial_should_error() {
        let nv = 0;
        let num_multiplicands_range = (4, 13);
        let num_products = 5;

        assert!(test_sumcheck(nv, num_multiplicands_range, num_products).is_err());
        assert!(test_sumcheck_internal(nv, num_multiplicands_range, num_products).is_err());
    }

    #[test]
    fn test_extract_sum() -> Result<(), anyhow::Error> {
        let mut rng = test_rng();
        let mut transcript = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::init_transcript();
        let (poly, asserted_sum) = VirtualPolynomial::<Fr>::rand(8, (3, 4), 3, &mut rng)?;

        let proof = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::prove(&poly, &mut transcript)?;
        assert_eq!(
            <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::extract_sum(&proof),
            asserted_sum
        );
        Ok(())
    }

    #[test]
    #[ignore]
    /// Test that the memory usage of shared-reference is linear to number of
    /// unique MLExtensions instead of total number of multiplicands.
    fn test_shared_reference() -> Result<(), anyhow::Error> {
        let mut rng = test_rng();
        let ml_extensions: Vec<_> = (0..5)
            .map(|_| Arc::new(Multilinear::<Fr>::random(8)))
            .collect();
        let mut poly = VirtualPolynomial::new(8);
        poly.add_mle_list(
            vec![
                ml_extensions[2].clone(),
                ml_extensions[3].clone(),
                ml_extensions[0].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![
                ml_extensions[1].clone(),
                ml_extensions[4].clone(),
                ml_extensions[4].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![
                ml_extensions[3].clone(),
                ml_extensions[2].clone(),
                ml_extensions[1].clone(),
            ],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(
            vec![ml_extensions[0].clone(), ml_extensions[0].clone()],
            Fr::rand(&mut rng),
        )?;
        poly.add_mle_list(vec![ml_extensions[4].clone()], Fr::rand(&mut rng))?;

        assert_eq!(poly.flattened_multilinear_poly.len(), 5);

        // test memory usage for prover
        let prover = VirtualProver::<Fr>::prover_init(&poly).unwrap();
        assert_eq!(prover.poly.flattened_multilinear_poly.len(), 5);
        drop(prover);

        let mut transcript = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::init_transcript();
        let poly_info = (poly.num_var, poly.max_degree);
        let proof = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::prove(&poly, &mut transcript)?;
        let asserted_sum = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::extract_sum(&proof);

        let mut transcript = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::init_transcript();
        let subclaim = <VirtualPolySumCheck<Fr> as SumCheck<Fr>>::verify(
            asserted_sum,
            &proof,
            &poly_info,
            &mut transcript,
        )?;
        assert!(
            poly.evaluate(&subclaim.point)? == subclaim.expected_evaluation,
            "wrong subclaim"
        );
        Ok(())
    }
}
