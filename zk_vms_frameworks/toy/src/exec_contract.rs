use std::{cell::RefCell, rc::Rc};

use revm::{
    primitives::{hex, Address, Bytes, U256},
    state::Bytecode,
};
use revm_interpreter::{
    host::DummyHost,
    instruction_table,
    interpreter::{EthInterpreter, ExtBytecode},
    InputsImpl, Interpreter, EMPTY_SHARED_MEMORY,
};

const BYTECODE: &str = "6080604052348015600e575f80fd5b5061038d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610034575f3560e01c8063771602f7146100385780639d34924114610068575b5f80fd5b610052600480360381019061004d91906101e7565b610098565b60405161005f9190610234565b60405180910390f35b610082600480360381019061007d919061024d565b6100b2565b60405161008f9190610234565b60405180910390f35b5f8082846100a691906102ca565b90508091505092915050565b5f80600367ffffffffffffffff8111156100cf576100ce6102fd565b5b6040519080825280602002602001820160405280156100fd5781602001602082028036833780820191505090505b50905084815f815181106101145761011361032a565b5b60200260200101818152505083816001815181106101355761013461032a565b5b60200260200101818152505082816002815181106101565761015561032a565b5b6020026020010181815250505f805b82518110156101a3578281815181106101815761018061032a565b5b60200260200101518261019491906102ca565b91508080600101915050610165565b5080925050509392505050565b5f80fd5b5f819050919050565b6101c6816101b4565b81146101d0575f80fd5b50565b5f813590506101e1816101bd565b92915050565b5f80604083850312156101fd576101fc6101b0565b5b5f61020a858286016101d3565b925050602061021b858286016101d3565b9150509250929050565b61022e816101b4565b82525050565b5f6020820190506102475f830184610225565b92915050565b5f805f60608486031215610264576102636101b0565b5b5f610271868287016101d3565b9350506020610282868287016101d3565b9250506040610293868287016101d3565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6102d4826101b4565b91506102df836101b4565b92508282019050808211156102f7576102f661029d565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffdfea26469706673582212204bce759a79ae99b700ec2eeeba1acc2035c114cc6500d707b45f7f7b090fd06e64736f6c634300081a0033";

pub fn exec_simple_smart_contract_add_fn() -> Vec<u8> {
    // add(uint256,uint256) => 0x771602f7
    // a = 50
    // b = 100
    // calldata = 771602f700000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000064
    let calldata = hex!("771602f700000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000064");

    let bytecode =
        Bytecode::new_raw_checked(Bytes::copy_from_slice(&hex::decode(BYTECODE).unwrap())).unwrap();

    let mut interpreter: Interpreter<EthInterpreter> = Interpreter::new(
        Rc::new(RefCell::new(EMPTY_SHARED_MEMORY)),
        ExtBytecode::new(bytecode),
        InputsImpl {
            target_address: Address::ZERO,
            caller_address: Address::ZERO,
            input: Bytes::copy_from_slice(&calldata),
            call_value: U256::ZERO,
        },
        false,
        false,
        revm::primitives::hardfork::SpecId::default(),
        u64::MAX,
    );

    let table = instruction_table::<EthInterpreter, DummyHost>();
    let mut host = DummyHost {};

    let out = interpreter.run_plain(&table, &mut host);
    let out: Vec<u8> = out.into_result_return().unwrap().output.into();

    out
}
